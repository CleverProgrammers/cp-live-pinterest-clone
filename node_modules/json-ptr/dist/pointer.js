"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonReference = exports.JsonPointer = void 0;
const util_1 = require("./util");
function isObject(value) {
    return typeof value === 'object' && value !== null;
}
function shouldDescend(obj) {
    return isObject(obj) && !JsonReference.isReference(obj);
}
function descendingVisit(target, visitor, encoder) {
    const distinctObjects = new Map();
    const q = [{ obj: target, path: [] }];
    while (q.length) {
        const { obj, path } = q.shift();
        visitor(encoder(path), obj);
        if (shouldDescend(obj)) {
            distinctObjects.set(obj, new JsonPointer(util_1.encodeUriFragmentIdentifier(path)));
            if (!Array.isArray(obj)) {
                const keys = Object.keys(obj);
                const len = keys.length;
                let i = -1;
                while (++i < len) {
                    const it = obj[keys[i]];
                    if (isObject(it) && distinctObjects.has(it)) {
                        q.push({
                            obj: new JsonReference(distinctObjects.get(it)),
                            path: path.concat(keys[i])
                        });
                    }
                    else {
                        q.push({
                            obj: it,
                            path: path.concat(keys[i])
                        });
                    }
                }
            }
            else {
                let j = -1;
                const len = obj.length;
                while (++j < len) {
                    const it = obj[j];
                    if (isObject(it) && distinctObjects.has(it)) {
                        q.push({
                            obj: new JsonReference(distinctObjects.get(it)),
                            path: path.concat([j + ''])
                        });
                    }
                    else {
                        q.push({
                            obj: it,
                            path: path.concat([j + ''])
                        });
                    }
                }
            }
        }
    }
}
const $ptr = Symbol('pointer');
const $frg = Symbol('fragmentId');
const $get = Symbol('getter');
class JsonPointer {
    constructor(ptr) {
        this.path = util_1.decodePtrInit(ptr);
    }
    static create(pointer) {
        return new JsonPointer(pointer);
    }
    static has(target, pointer) {
        if (typeof pointer === 'string' || Array.isArray(pointer)) {
            pointer = new JsonPointer(pointer);
        }
        return pointer.has(target);
    }
    static get(target, pointer) {
        if (typeof pointer === 'string' || Array.isArray(pointer)) {
            pointer = new JsonPointer(pointer);
        }
        return pointer.get(target);
    }
    static set(target, pointer, val, force = false) {
        if (typeof pointer === 'string' || Array.isArray(pointer)) {
            pointer = new JsonPointer(pointer);
        }
        return pointer.set(target, val, force);
    }
    static unset(target, pointer) {
        if (typeof pointer === 'string' || Array.isArray(pointer)) {
            pointer = new JsonPointer(pointer);
        }
        return pointer.unset(target);
    }
    static decode(pointer) {
        return util_1.pickDecoder(pointer)(pointer);
    }
    static visit(target, visitor, fragmentId = false) {
        descendingVisit(target, visitor, fragmentId ? util_1.encodeUriFragmentIdentifier : util_1.encodePointer);
    }
    static listPointers(target) {
        const res = [];
        descendingVisit(target, (pointer, value) => {
            res.push({ pointer, value });
        }, util_1.encodePointer);
        return res;
    }
    static listFragmentIds(target) {
        const res = [];
        descendingVisit(target, (fragmentId, value) => {
            res.push({ fragmentId, value });
        }, util_1.encodeUriFragmentIdentifier);
        return res;
    }
    static flatten(target, fragmentId = false) {
        const res = {};
        descendingVisit(target, (p, v) => {
            res[p] = v;
        }, fragmentId ? util_1.encodeUriFragmentIdentifier : util_1.encodePointer);
        return res;
    }
    static map(target, fragmentId = false) {
        const res = new Map();
        descendingVisit(target, res.set.bind(res), fragmentId ? util_1.encodeUriFragmentIdentifier : util_1.encodePointer);
        return res;
    }
    get(target) {
        if (!this[$get]) {
            this[$get] = util_1.compilePointerDereference(this.path);
        }
        return this[$get](target);
    }
    set(target, value, force = false) {
        return util_1.setValueAtPath(target, value, this.path, force);
    }
    unset(target) {
        return util_1.unsetValueAtPath(target, this.path);
    }
    has(target) {
        return typeof this.get(target) !== 'undefined';
    }
    concat(ptr) {
        return new JsonPointer(this.path.concat(ptr instanceof JsonPointer ? ptr.path : util_1.decodePtrInit(ptr)));
    }
    get pointer() {
        if (this[$ptr] === undefined) {
            this[$ptr] = util_1.encodePointer(this.path);
        }
        return this[$ptr];
    }
    get uriFragmentIdentifier() {
        if (!this[$frg]) {
            this[$frg] = util_1.encodeUriFragmentIdentifier(this.path);
        }
        return this[$frg];
    }
    toString() {
        return this.pointer;
    }
}
exports.JsonPointer = JsonPointer;
const $pointer = Symbol('pointer');
class JsonReference {
    constructor(pointer) {
        this[$pointer] = pointer instanceof JsonPointer ? pointer : new JsonPointer(pointer);
        this.$ref = this[$pointer].uriFragmentIdentifier;
    }
    static isReference(candidate) {
        if (!candidate)
            return false;
        const ref = candidate;
        return typeof ref.$ref === 'string' && typeof ref.resolve === 'function';
    }
    resolve(target) {
        return this[$pointer].get(target);
    }
    pointer() { return this[$pointer]; }
    toString() {
        return this.$ref;
    }
}
exports.JsonReference = JsonReference;
//# sourceMappingURL=pointer.js.map