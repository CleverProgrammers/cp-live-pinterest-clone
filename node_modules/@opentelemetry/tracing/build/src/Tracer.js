"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tracer = void 0;
const api = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const Span_1 = require("./Span");
const utility_1 = require("./utility");
/**
 * This class represents a basic tracer.
 */
class Tracer {
    /**
     * Constructs a new Tracer instance.
     */
    constructor(instrumentationLibrary, config, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        const localConfig = utility_1.mergeConfig(config);
        this._sampler = localConfig.sampler;
        this._traceParams = localConfig.traceParams;
        this._idGenerator = config.idGenerator || new core_1.RandomIdGenerator();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
        this.logger = config.logger || new core_1.ConsoleLogger(config.logLevel);
    }
    /**
     * Starts a new Span or returns the default NoopSpan based on the sampling
     * decision.
     */
    startSpan(name, options = {}, context = api.context.active()) {
        var _a, _b;
        if (api.isInstrumentationSuppressed(context)) {
            this.logger.debug('Instrumentation suppressed, returning Noop Span');
            return api.NOOP_SPAN;
        }
        const parentContext = getParent(options, context);
        const spanId = this._idGenerator.generateSpanId();
        let traceId;
        let traceState;
        if (!parentContext || !api.trace.isSpanContextValid(parentContext)) {
            // New root span.
            traceId = this._idGenerator.generateTraceId();
        }
        else {
            // New child span.
            traceId = parentContext.traceId;
            traceState = parentContext.traceState;
        }
        const spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL;
        const links = (_b = options.links) !== null && _b !== void 0 ? _b : [];
        const attributes = core_1.sanitizeAttributes(options.attributes);
        // make sampling decision
        const samplingResult = this._sampler.shouldSample(parentContext, traceId, name, spanKind, attributes, links);
        const traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED
            ? api.TraceFlags.SAMPLED
            : api.TraceFlags.NONE;
        const spanContext = { traceId, spanId, traceFlags, traceState };
        if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {
            this.logger.debug('Recording is off, starting no recording span');
            return new core_1.NoRecordingSpan(spanContext);
        }
        const span = new Span_1.Span(this, name, spanContext, spanKind, parentContext ? parentContext.spanId : undefined, links, options.startTime);
        // Set default attributes
        span.setAttributes(Object.assign(attributes, samplingResult.attributes));
        return span;
    }
    /**
     * Returns the current Span from the current context.
     *
     * If there is no Span associated with the current context, undefined is returned.
     */
    getCurrentSpan() {
        const ctx = api.context.active();
        // Get the current Span from the context or null if none found.
        return api.getActiveSpan(ctx);
    }
    /**
     * Enters the context of code where the given Span is in the current context.
     */
    withSpan(span, fn) {
        // Set given span to context.
        return api.context.with(api.setActiveSpan(api.context.active(), span), fn);
    }
    /**
     * Bind a span (or the current one) to the target's context
     */
    bind(target, span) {
        return api.context.bind(target, span
            ? api.setActiveSpan(api.context.active(), span)
            : api.context.active());
    }
    /** Returns the active {@link TraceParams}. */
    getActiveTraceParams() {
        return this._traceParams;
    }
    getActiveSpanProcessor() {
        return this._tracerProvider.getActiveSpanProcessor();
    }
}
exports.Tracer = Tracer;
/**
 * Get the parent to assign to a started span. If options.parent is null,
 * do not assign a parent.
 *
 * @param options span options
 * @param context context to check for parent
 */
function getParent(options, context) {
    if (options.parent === null)
        return undefined;
    if (options.parent)
        return getContext(options.parent);
    return api.getParentSpanContext(context);
}
function getContext(span) {
    return isSpan(span) ? span.context() : span;
}
function isSpan(span) {
    return typeof span.context === 'function';
}
//# sourceMappingURL=Tracer.js.map