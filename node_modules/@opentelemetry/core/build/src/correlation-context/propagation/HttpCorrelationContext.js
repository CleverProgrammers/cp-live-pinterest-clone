"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpCorrelationContext = exports.MAX_TOTAL_LENGTH = exports.MAX_PER_NAME_VALUE_PAIRS = exports.MAX_NAME_VALUE_PAIRS = exports.CORRELATION_CONTEXT_HEADER = void 0;
const correlation_context_1 = require("../correlation-context");
const KEY_PAIR_SEPARATOR = '=';
const PROPERTIES_SEPARATOR = ';';
const ITEMS_SEPARATOR = ',';
// Name of the http header used to propagate the correlation context
exports.CORRELATION_CONTEXT_HEADER = 'baggage';
// Maximum number of name-value pairs allowed by w3c spec
exports.MAX_NAME_VALUE_PAIRS = 180;
// Maximum number of bytes per a single name-value pair allowed by w3c spec
exports.MAX_PER_NAME_VALUE_PAIRS = 4096;
// Maximum total length of all name-value pairs allowed by w3c spec
exports.MAX_TOTAL_LENGTH = 8192;
/**
 * Propagates {@link CorrelationContext} through Context format propagation.
 *
 * Based on the Correlation Context specification:
 * https://w3c.github.io/correlation-context/
 */
class HttpCorrelationContext {
    inject(context, carrier, setter) {
        const correlationContext = correlation_context_1.getCorrelationContext(context);
        if (!correlationContext)
            return;
        const keyPairs = this._getKeyPairs(correlationContext)
            .filter((pair) => {
            return pair.length <= exports.MAX_PER_NAME_VALUE_PAIRS;
        })
            .slice(0, exports.MAX_NAME_VALUE_PAIRS);
        const headerValue = this._serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
            setter(carrier, exports.CORRELATION_CONTEXT_HEADER, headerValue);
        }
    }
    _serializeKeyPairs(keyPairs) {
        return keyPairs.reduce((hValue, current) => {
            const value = `${hValue}${hValue != '' ? ITEMS_SEPARATOR : ''}${current}`;
            return value.length > exports.MAX_TOTAL_LENGTH ? hValue : value;
        }, '');
    }
    _getKeyPairs(correlationContext) {
        return Object.keys(correlationContext).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(correlationContext[key].value)}`);
    }
    extract(context, carrier, getter) {
        const headerValue = getter(carrier, exports.CORRELATION_CONTEXT_HEADER);
        if (!headerValue)
            return context;
        const correlationContext = {};
        if (headerValue.length == 0) {
            return context;
        }
        const pairs = headerValue.split(ITEMS_SEPARATOR);
        pairs.forEach(entry => {
            const keyPair = this._parsePairKeyValue(entry);
            if (keyPair) {
                correlationContext[keyPair.key] = { value: keyPair.value };
            }
        });
        if (Object.entries(correlationContext).length === 0) {
            return context;
        }
        return correlation_context_1.setCorrelationContext(context, correlationContext);
    }
    _parsePairKeyValue(entry) {
        const valueProps = entry.split(PROPERTIES_SEPARATOR);
        if (valueProps.length <= 0)
            return;
        const keyPairPart = valueProps.shift();
        if (!keyPairPart)
            return;
        const keyPair = keyPairPart.split(KEY_PAIR_SEPARATOR);
        if (keyPair.length != 2)
            return;
        const key = decodeURIComponent(keyPair[0].trim());
        let value = decodeURIComponent(keyPair[1].trim());
        if (valueProps.length > 0) {
            value =
                value + PROPERTIES_SEPARATOR + valueProps.join(PROPERTIES_SEPARATOR);
        }
        return { key, value };
    }
}
exports.HttpCorrelationContext = HttpCorrelationContext;
//# sourceMappingURL=HttpCorrelationContext.js.map