"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printTriggerUrls = exports.printSuccess = exports.logAndTrackDeployStats = exports.toJob = exports.getFunctionLabel = exports.getRegion = exports.getTopicName = exports.getScheduleName = exports.getFunctionId = exports.getFunctionTrigger = exports.logFilters = exports.getReleaseNames = exports.getFilterGroups = exports.functionMatchesGroup = exports.functionMatchesAnyGroup = void 0;
const _ = require("lodash");
const clc = require("cli-color");
const error_1 = require("./error");
const logger = require("./logger");
const track = require("./track");
const utils = require("./utils");
const cloudfunctions = require("./gcp/cloudfunctions");
function functionMatchesAnyGroup(fnName, filterGroups) {
    if (!filterGroups.length) {
        return true;
    }
    for (const groupChunks of filterGroups) {
        if (functionMatchesGroup(fnName, groupChunks)) {
            return true;
        }
    }
    return false;
}
exports.functionMatchesAnyGroup = functionMatchesAnyGroup;
function functionMatchesGroup(functionName, groupChunks) {
    const last = _.last(functionName.split("/"));
    if (!last) {
        return false;
    }
    const functionNameChunks = last.split("-").slice(0, groupChunks.length);
    return _.isEqual(groupChunks, functionNameChunks);
}
exports.functionMatchesGroup = functionMatchesGroup;
function getFilterGroups(options) {
    if (!options.only) {
        return [];
    }
    let opts;
    return _.chain(options.only.split(","))
        .filter((filter) => {
        opts = filter.split(":");
        return opts[0] === "functions" && opts[1];
    })
        .map((filter) => {
        return filter.split(":")[1].split(/[.-]/);
    })
        .value();
}
exports.getFilterGroups = getFilterGroups;
function getReleaseNames(uploadNames, existingNames, functionFilterGroups) {
    if (functionFilterGroups.length === 0) {
        return uploadNames;
    }
    const allFunctions = _.union(uploadNames, existingNames);
    return _.filter(allFunctions, (functionName) => {
        return _.some(_.map(functionFilterGroups, (groupChunks) => {
            return functionMatchesGroup(functionName, groupChunks);
        }));
    });
}
exports.getReleaseNames = getReleaseNames;
function logFilters(existingNames, releaseNames, functionFilterGroups) {
    if (functionFilterGroups.length === 0) {
        return;
    }
    logger.debug("> [functions] filtering triggers to: " + JSON.stringify(releaseNames, null, 2));
    track("Functions Deploy with Filter", "", releaseNames.length);
    let list;
    if (existingNames.length > 0) {
        list = _.map(existingNames, (name) => {
            return getFunctionId(name) + "(" + getRegion(name) + ")";
        }).join(", ");
        utils.logBullet(clc.bold.cyan("functions: ") + "current functions in project: " + list);
    }
    if (releaseNames.length > 0) {
        list = _.map(releaseNames, (name) => {
            return getFunctionId(name) + "(" + getRegion(name) + ")";
        }).join(", ");
        utils.logBullet(clc.bold.cyan("functions: ") + "uploading functions in project: " + list);
    }
    const allFunctions = _.union(releaseNames, existingNames);
    const unmatchedFilters = _.chain(functionFilterGroups)
        .filter((filterGroup) => {
        return !_.some(_.map(allFunctions, (functionName) => {
            return functionMatchesGroup(functionName, filterGroup);
        }));
    })
        .map((group) => {
        return group.join("-");
    })
        .value();
    if (unmatchedFilters.length > 0) {
        utils.logWarning(clc.bold.yellow("functions: ") +
            "the following filters were specified but do not match any functions in the project: " +
            unmatchedFilters.join(", "));
    }
}
exports.logFilters = logFilters;
function getFunctionTrigger(functionInfo) {
    if (functionInfo.httpsTrigger) {
        return { httpsTrigger: functionInfo.httpsTrigger };
    }
    else if (functionInfo.eventTrigger) {
        const trigger = functionInfo.eventTrigger;
        trigger.failurePolicy = functionInfo.failurePolicy;
        return { eventTrigger: trigger };
    }
    logger.debug("Unknown trigger type found in:", functionInfo);
    throw new error_1.FirebaseError("Could not parse function trigger, unknown trigger type.");
}
exports.getFunctionTrigger = getFunctionTrigger;
function getFunctionId(fullName) {
    return fullName.split("/")[5];
}
exports.getFunctionId = getFunctionId;
function getScheduleName(fullName, appEngineLocation) {
    const [projectsPrefix, project, regionsPrefix, region, , functionName] = fullName.split("/");
    return `${projectsPrefix}/${project}/${regionsPrefix}/${appEngineLocation}/jobs/firebase-schedule-${functionName}-${region}`;
}
exports.getScheduleName = getScheduleName;
function getTopicName(fullName) {
    const [projectsPrefix, project, , region, , functionName] = fullName.split("/");
    return `${projectsPrefix}/${project}/topics/firebase-schedule-${functionName}-${region}`;
}
exports.getTopicName = getTopicName;
function getRegion(fullName) {
    return fullName.split("/")[3];
}
exports.getRegion = getRegion;
function getFunctionLabel(fullName) {
    return getFunctionId(fullName) + "(" + getRegion(fullName) + ")";
}
exports.getFunctionLabel = getFunctionLabel;
function toJob(fn, appEngineLocation, projectId) {
    return Object.assign(fn.schedule, {
        name: getScheduleName(fn.name, appEngineLocation),
        pubsubTarget: {
            topicName: getTopicName(fn.name),
            attributes: {
                scheduled: "true",
            },
        },
    });
}
exports.toJob = toJob;
function logAndTrackDeployStats(queue, errorHandler) {
    const stats = queue.stats();
    logger.debug(`Total Function Deployment time: ${stats.elapsed}`);
    logger.debug(`${stats.total} Functions Deployed`);
    logger.debug(`${errorHandler.errors.length} Functions Errored`);
    logger.debug(`Average Function Deployment time: ${stats.avg}`);
    if (stats.total > 0) {
        track("Functions Deploy (Result)", "failure", stats.errored);
        track("Functions Deploy (Result)", "success", stats.success);
    }
}
exports.logAndTrackDeployStats = logAndTrackDeployStats;
function printSuccess(funcName, type) {
    utils.logSuccess(clc.bold.green("functions[" + getFunctionLabel(funcName) + "]: ") +
        "Successful " +
        type +
        " operation. ");
}
exports.printSuccess = printSuccess;
async function printTriggerUrls(projectId, sourceUrl) {
    const functions = await cloudfunctions.listAllFunctions(projectId);
    const httpsFunctions = functions.filter((fn) => {
        return fn.sourceUploadUrl === sourceUrl && fn.httpsTrigger;
    });
    if (httpsFunctions.length === 0) {
        return;
    }
    httpsFunctions.forEach((httpsFunc) => {
        var _a;
        logger.info(clc.bold("Function URL"), `(${getFunctionId(httpsFunc.name)}):`, (_a = httpsFunc.httpsTrigger) === null || _a === void 0 ? void 0 : _a.url);
    });
    return;
}
exports.printTriggerUrls = printTriggerUrls;
