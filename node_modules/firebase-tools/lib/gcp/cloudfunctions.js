"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listAllFunctions = exports.listFunctions = exports.deleteFunction = exports.updateFunction = exports.setIamPolicy = exports.createFunction = exports.generateUploadUrl = exports.DEFAULT_PUBLIC_POLICY = exports.API_VERSION = void 0;
const _ = require("lodash");
const clc = require("cli-color");
const api = require("../api");
const error_1 = require("../error");
const logger = require("../logger");
const utils = require("../utils");
exports.API_VERSION = "v1";
exports.DEFAULT_PUBLIC_POLICY = {
    version: 3,
    bindings: [
        {
            role: "roles/cloudfunctions.invoker",
            members: ["allUsers"],
        },
    ],
};
function functionsOpLogReject(funcName, type, err) {
    var _a, _b;
    utils.logWarning(clc.bold.yellow("functions:") + " failed to " + type + " function " + funcName);
    if (((_b = (_a = err === null || err === void 0 ? void 0 : err.context) === null || _a === void 0 ? void 0 : _a.response) === null || _b === void 0 ? void 0 : _b.statusCode) === 429) {
        logger.debug(err.message);
        logger.info("You have exceeded your deployment quota, please deploy your functions in batches by using the --only flag, " +
            "and wait a few minutes before deploying again. Go to https://firebase.google.com/docs/cli/#partial_deploys to learn more.");
    }
    else {
        logger.info(err.message);
    }
    throw new error_1.FirebaseError(`Failed to ${type} function ${funcName}`, {
        original: err,
        context: { function: funcName },
    });
}
async function generateUploadUrl(projectId, location) {
    const parent = "projects/" + projectId + "/locations/" + location;
    const endpoint = "/" + exports.API_VERSION + "/" + parent + "/functions:generateUploadUrl";
    try {
        const res = await api.request("POST", endpoint, {
            auth: true,
            json: false,
            origin: api.functionsOrigin,
            retryCodes: [503],
        });
        const responseBody = JSON.parse(res.body);
        return responseBody.uploadUrl;
    }
    catch (err) {
        logger.info("\n\nThere was an issue deploying your functions. Verify that your project has a Google App Engine instance setup at https://console.cloud.google.com/appengine and try again. If this issue persists, please contact support.");
        throw err;
    }
}
exports.generateUploadUrl = generateUploadUrl;
async function createFunction(options) {
    var _a;
    const location = "projects/" + options.projectId + "/locations/" + options.region;
    const fullFuncName = location + "/functions/" + options.functionName;
    const endpoint = "/" + exports.API_VERSION + "/" + location + "/functions";
    const data = {
        sourceUploadUrl: options.sourceUploadUrl,
        name: fullFuncName,
        entryPoint: options.entryPoint,
        labels: options.labels,
        runtime: options.runtime,
        environmentVariables: options.environmentVariables,
    };
    if (options.vpcConnector) {
        data.vpcConnector = options.vpcConnector;
        if (!((_a = data.vpcConnector) === null || _a === void 0 ? void 0 : _a.includes("/"))) {
            data.vpcConnector = `${location}/connectors/${data.vpcConnector}`;
        }
    }
    if (options.vpcConnectorEgressSettings) {
        data.vpcConnectorEgressSettings = options.vpcConnectorEgressSettings;
    }
    if (options.availableMemoryMb) {
        data.availableMemoryMb = options.availableMemoryMb;
    }
    if (options.timeout) {
        data.timeout = options.timeout;
    }
    if (options.maxInstances) {
        data.maxInstances = Number(options.maxInstances);
    }
    if (options.serviceAccountEmail) {
        data.serviceAccountEmail = options.serviceAccountEmail;
    }
    if (options.sourceToken) {
        data.sourceToken = options.sourceToken;
    }
    try {
        const res = await api.request("POST", endpoint, {
            auth: true,
            data: _.assign(data, options.trigger),
            origin: api.functionsOrigin,
        });
        return {
            name: res.body.name,
            type: "create",
            funcName: fullFuncName,
            eventType: options.eventType,
            done: false,
        };
    }
    catch (err) {
        throw functionsOpLogReject(options.functionName, "create", err);
    }
}
exports.createFunction = createFunction;
async function setIamPolicy(options) {
    const endpoint = `/${exports.API_VERSION}/${options.name}:setIamPolicy`;
    try {
        await api.request("POST", endpoint, {
            auth: true,
            data: {
                policy: options.policy,
                updateMask: Object.keys(options.policy).join(","),
            },
            origin: api.functionsOrigin,
        });
    }
    catch (err) {
        throw new error_1.FirebaseError(`Failed to set the IAM Policy on the function ${options.name}`, {
            original: err,
        });
    }
}
exports.setIamPolicy = setIamPolicy;
async function updateFunction(options) {
    var _a;
    const location = "projects/" + options.projectId + "/locations/" + options.region;
    const fullFuncName = location + "/functions/" + options.functionName;
    const endpoint = "/" + exports.API_VERSION + "/" + fullFuncName;
    const data = _.assign({
        sourceUploadUrl: options.sourceUploadUrl,
        name: fullFuncName,
        labels: options.labels,
    }, options.trigger);
    let masks = ["sourceUploadUrl", "name", "labels"];
    if (options.vpcConnector) {
        data.vpcConnector = options.vpcConnector;
        if (!((_a = data.vpcConnector) === null || _a === void 0 ? void 0 : _a.includes("/"))) {
            data.vpcConnector = `${location}/connectors/${data.vpcConnector}`;
        }
        masks.push("vpcConnector");
    }
    if (options.vpcConnectorEgressSettings) {
        data.vpcConnectorEgressSettings = options.vpcConnectorEgressSettings;
        masks.push("vpcConnectorEgressSettings");
    }
    if (options.runtime) {
        data.runtime = options.runtime;
        masks = _.concat(masks, "runtime");
    }
    if (options.availableMemoryMb) {
        data.availableMemoryMb = options.availableMemoryMb;
        masks.push("availableMemoryMb");
    }
    if (options.timeout) {
        data.timeout = options.timeout;
        masks.push("timeout");
    }
    if (options.maxInstances) {
        data.maxInstances = Number(options.maxInstances);
        masks.push("maxInstances");
    }
    if (options.environmentVariables) {
        data.environmentVariables = options.environmentVariables;
        masks.push("environmentVariables");
    }
    if (options.serviceAccountEmail) {
        data.serviceAccountEmail = options.serviceAccountEmail;
        masks.push("serviceAccountEmail");
    }
    if (options.sourceToken) {
        data.sourceToken = options.sourceToken;
        masks.push("sourceToken");
    }
    if (options.trigger.eventTrigger) {
        masks = _.concat(masks, _.map(_.keys(options.trigger.eventTrigger), (subkey) => {
            return "eventTrigger." + subkey;
        }));
    }
    else {
        masks = _.concat(masks, "httpsTrigger");
    }
    try {
        const res = await api.request("PATCH", endpoint, {
            qs: {
                updateMask: masks.join(","),
            },
            auth: true,
            data: data,
            origin: api.functionsOrigin,
        });
        return {
            funcName: fullFuncName,
            eventType: options.eventType,
            done: false,
            name: res.body.name,
            type: "update",
        };
    }
    catch (err) {
        throw functionsOpLogReject(options.functionName, "update", err);
    }
}
exports.updateFunction = updateFunction;
async function deleteFunction(options) {
    const endpoint = "/" + exports.API_VERSION + "/" + options.functionName;
    try {
        const res = await api.request("DELETE", endpoint, {
            auth: true,
            origin: api.functionsOrigin,
        });
        return {
            funcName: options.funcName,
            eventType: options.eventType,
            done: false,
            name: res.body.name,
            type: "delete",
        };
    }
    catch (err) {
        throw functionsOpLogReject(options.functionName, "delete", err);
    }
}
exports.deleteFunction = deleteFunction;
async function listFunctions(projectId, region) {
    const endpoint = "/" + exports.API_VERSION + "/projects/" + projectId + "/locations/" + region + "/functions";
    try {
        const res = await api.request("GET", endpoint, {
            auth: true,
            origin: api.functionsOrigin,
        });
        if (res.body.unreachable && res.body.unreachable.length > 0) {
            throw new error_1.FirebaseError("Some Cloud Functions regions were unreachable, please try again later.", { exit: 2 });
        }
        const functionsList = res.body.functions || [];
        _.forEach(functionsList, (f) => {
            f.functionName = f.name.substring(f.name.lastIndexOf("/") + 1);
        });
        return functionsList;
    }
    catch (err) {
        logger.debug("[functions] failed to list functions for " + projectId);
        logger.debug("[functions] " + err.message);
        return Promise.reject(err.message);
    }
}
exports.listFunctions = listFunctions;
async function listAllFunctions(projectId) {
    return listFunctions(projectId, "-");
}
exports.listAllFunctions = listAllFunctions;
