"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.promptForFunctionDeletion = exports.promptForFailurePolicies = void 0;
const clc = require("cli-color");
const functionsDeployHelper_1 = require("../../functionsDeployHelper");
const error_1 = require("../../error");
const prompt_1 = require("../../prompt");
const utils = require("../../utils");
const logger = require("../../logger");
async function promptForFailurePolicies(options, functions) {
    const failurePolicyFunctions = functions.filter((fn) => {
        return !!fn.failurePolicy;
    });
    if (failurePolicyFunctions.length === 0) {
        return;
    }
    const failurePolicyFunctionLabels = failurePolicyFunctions.map((fn) => {
        return functionsDeployHelper_1.getFunctionLabel(fn.name);
    });
    const retryMessage = "The following functions will be retried in case of failure: " +
        clc.bold(failurePolicyFunctionLabels.join(", ")) +
        ". " +
        "Retried executions are billed as any other execution, and functions are retried repeatedly until they either successfully execute or the maximum retry period has elapsed, which can be up to 7 days. " +
        "For safety, you might want to ensure that your functions are idempotent; see https://firebase.google.com/docs/functions/retries to learn more.";
    utils.logLabeledWarning("functions", retryMessage);
    if (options.force) {
        return;
    }
    else if (options.nonInteractive) {
        throw new error_1.FirebaseError("Pass the --force option to deploy functions with a failure policy", {
            exit: 1,
        });
    }
    const proceed = await prompt_1.promptOnce({
        type: "confirm",
        name: "confirm",
        default: false,
        message: "Would you like to proceed with deployment?",
    });
    if (!proceed) {
        throw new error_1.FirebaseError("Deployment canceled.", { exit: 1 });
    }
}
exports.promptForFailurePolicies = promptForFailurePolicies;
async function promptForFunctionDeletion(functionsToDelete, force, nonInteractive) {
    let shouldDeleteFns = true;
    if (functionsToDelete.length === 0 || force) {
        return true;
    }
    const deleteList = functionsToDelete
        .map((funcName) => {
        return "\t" + functionsDeployHelper_1.getFunctionLabel(funcName);
    })
        .join("\n");
    if (nonInteractive) {
        const deleteCommands = functionsToDelete
            .map((func) => {
            return ("\tfirebase functions:delete " + functionsDeployHelper_1.getFunctionId(func) + " --region " + functionsDeployHelper_1.getRegion(func));
        })
            .join("\n");
        throw new error_1.FirebaseError("The following functions are found in your project but do not exist in your local source code:\n" +
            deleteList +
            "\n\nAborting because deletion cannot proceed in non-interactive mode. To fix, manually delete the functions by running:\n" +
            clc.bold(deleteCommands));
    }
    else {
        logger.info("\nThe following functions are found in your project but do not exist in your local source code:\n" +
            deleteList +
            "\n\nIf you are renaming a function or changing its region, it is recommended that you create the new " +
            "function first before deleting the old one to prevent event loss. For more info, visit " +
            clc.underline("https://firebase.google.com/docs/functions/manage-functions#modify" + "\n"));
        shouldDeleteFns = await prompt_1.promptOnce({
            type: "confirm",
            name: "confirm",
            default: false,
            message: "Would you like to proceed with deletion? Selecting no will continue the rest of the deployments.",
        });
    }
    return shouldDeleteFns;
}
exports.promptForFunctionDeletion = promptForFunctionDeletion;
