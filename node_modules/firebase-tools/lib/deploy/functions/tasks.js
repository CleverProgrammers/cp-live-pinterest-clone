"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runRegionalFunctionDeployment = exports.deleteScheduleTask = exports.upsertScheduleTask = exports.deleteFunctionTask = exports.updateFunctionTask = exports.createFunctionTask = void 0;
const clc = require("cli-color");
const logger = require("../../logger");
const utils = require("../../utils");
const gcp_1 = require("../../gcp");
const deploymentTool = require("../../deploymentTool");
const helper = require("../../functionsDeployHelper");
const operation_poller_1 = require("../../operation-poller");
const api_1 = require("../../api");
const parseRuntimeAndValidateSDK_1 = require("../../parseRuntimeAndValidateSDK");
const pubsub_1 = require("../../gcp/pubsub");
const defaultPollerOptions = {
    apiOrigin: api_1.functionsOrigin,
    apiVersion: gcp_1.cloudfunctions.API_VERSION,
    masterTimeout: 300000,
};
function createFunctionTask(params, fn, onPoll) {
    return async () => {
        utils.logBullet(clc.bold.cyan("functions: ") +
            "creating " +
            parseRuntimeAndValidateSDK_1.getHumanFriendlyRuntimeName(params.runtime) +
            " function " +
            clc.bold(helper.getFunctionLabel(fn.name)) +
            "...");
        params.timer.startTimer(fn.name, "create");
        const eventType = fn.eventTrigger ? fn.eventTrigger.eventType : "https";
        try {
            const createRes = await gcp_1.cloudfunctions.createFunction({
                projectId: params.projectId,
                region: helper.getRegion(fn.name),
                eventType: eventType,
                functionName: helper.getFunctionId(fn.name),
                entryPoint: fn.entryPoint,
                trigger: helper.getFunctionTrigger(fn),
                labels: Object.assign({}, deploymentTool.labels(), fn.labels),
                sourceUploadUrl: params.sourceUrl,
                sourceToken: params.sourceToken,
                runtime: params.runtime,
                availableMemoryMb: fn.availableMemoryMb,
                timeout: fn.timeout,
                maxInstances: fn.maxInstances,
                environmentVariables: fn.environmentVariables,
                vpcConnector: fn.vpcConnector,
                vpcConnectorEgressSettings: fn.vpcConnectorEgressSettings,
                serviceAccountEmail: fn.serviceAccountEmail,
            });
            const pollerOptions = Object.assign({
                pollerName: `create-${fn.name}`,
                operationResourceName: createRes.name,
                onPoll,
            }, defaultPollerOptions);
            const operationResult = await operation_poller_1.pollOperation(pollerOptions);
            if (eventType === "https") {
                try {
                    await gcp_1.cloudfunctions.setIamPolicy({
                        name: fn.name,
                        policy: gcp_1.cloudfunctions.DEFAULT_PUBLIC_POLICY,
                    });
                }
                catch (err) {
                    params.errorHandler.record("warning", fn.name, "make public", err.message);
                }
            }
            params.timer.endTimer(fn.name);
            helper.printSuccess(fn.name, "create");
            return operationResult;
        }
        catch (err) {
            params.errorHandler.record("error", fn.name, "create", err.message || "");
        }
    };
}
exports.createFunctionTask = createFunctionTask;
function updateFunctionTask(params, fn, onPoll) {
    return async () => {
        utils.logBullet(clc.bold.cyan("functions: ") +
            "updating " +
            parseRuntimeAndValidateSDK_1.getHumanFriendlyRuntimeName(params.runtime) +
            " function " +
            clc.bold(helper.getFunctionLabel(fn.name)) +
            "...");
        params.timer.startTimer(fn.name, "update");
        const eventType = fn.eventTrigger ? fn.eventTrigger.eventType : "https";
        try {
            const updateRes = await gcp_1.cloudfunctions.updateFunction({
                projectId: params.projectId,
                region: helper.getRegion(fn.name),
                eventType: eventType,
                functionName: helper.getFunctionId(fn.name),
                entryPoint: fn.entryPoint,
                trigger: helper.getFunctionTrigger(fn),
                labels: Object.assign({}, deploymentTool.labels(), fn.labels),
                sourceUploadUrl: params.sourceUrl,
                sourceToken: params.sourceToken,
                runtime: params.runtime,
                availableMemoryMb: fn.availableMemoryMb,
                timeout: fn.timeout,
                maxInstances: fn.maxInstances,
                environmentVariables: fn.environmentVariables,
                vpcConnector: fn.vpcConnector,
                vpcConnectorEgressSettings: fn.vpcConnectorEgressSettings,
                serviceAccountEmail: fn.serviceAccountEmail,
            });
            const pollerOptions = Object.assign({
                pollerName: `update-${fn.name}`,
                operationResourceName: updateRes.name,
                onPoll,
            }, defaultPollerOptions);
            const operationResult = await operation_poller_1.pollOperation(pollerOptions);
            params.timer.endTimer(fn.name);
            helper.printSuccess(fn.name, "update");
            return operationResult;
        }
        catch (err) {
            params.errorHandler.record("error", fn.name, "update", err.message || "");
        }
    };
}
exports.updateFunctionTask = updateFunctionTask;
function deleteFunctionTask(params, fnName) {
    return async () => {
        utils.logBullet(clc.bold.cyan("functions: ") +
            "deleting function " +
            clc.bold(helper.getFunctionLabel(fnName)) +
            "...");
        params.timer.startTimer(fnName, "delete");
        try {
            const deleteRes = await gcp_1.cloudfunctions.deleteFunction({
                functionName: fnName,
            });
            const pollerOptions = Object.assign({
                pollerName: `delete-${fnName}`,
                operationResourceName: deleteRes.name,
            }, defaultPollerOptions);
            const operationResult = await operation_poller_1.pollOperation(pollerOptions);
            params.timer.endTimer(fnName);
            helper.printSuccess(fnName, "delete");
            return operationResult;
        }
        catch (err) {
            params.errorHandler.record("error", fnName, "delete", err.message || "");
        }
    };
}
exports.deleteFunctionTask = deleteFunctionTask;
function upsertScheduleTask(params, fn, appEngineLocation) {
    return async () => {
        const job = helper.toJob(fn, appEngineLocation, params.projectId);
        try {
            await gcp_1.cloudscheduler.createOrReplaceJob(job);
            helper.printSuccess(fn.name, "upsert schedule");
        }
        catch (err) {
            params.errorHandler.record("error", fn.name, "upsert schedule", err.message || "");
        }
    };
}
exports.upsertScheduleTask = upsertScheduleTask;
function deleteScheduleTask(params, fnName, appEngineLocation) {
    return async () => {
        const jobName = helper.getScheduleName(fnName, appEngineLocation);
        const topicName = helper.getTopicName(fnName);
        try {
            await gcp_1.cloudscheduler.deleteJob(jobName);
        }
        catch (err) {
            if (err.status !== 404) {
                params.errorHandler.record("error", fnName, "delete schedule", err.message || "");
                return;
            }
            logger.debug(`Scheduler job ${jobName} not found.`);
        }
        try {
            await pubsub_1.deleteTopic(topicName);
            helper.printSuccess(fnName, "delete schedule");
        }
        catch (err) {
            if (err.status !== 404) {
                params.errorHandler.record("error", fnName, "delete schedule", err.message || "");
                return;
            }
            logger.debug(`Scheduler topic ${topicName} not found.`);
        }
    };
}
exports.deleteScheduleTask = deleteScheduleTask;
function runRegionalFunctionDeployment(params, regionalDeployment, queue) {
    const onPollFn = (op) => {
        var _a, _b;
        const shouldFinishDeployment = (((_a = op.metadata) === null || _a === void 0 ? void 0 : _a.sourceToken) && !regionalDeployment.sourceToken) ||
            (!((_b = op.metadata) === null || _b === void 0 ? void 0 : _b.sourceToken) && op.done);
        if (shouldFinishDeployment) {
            logger.debug(`Got sourceToken ${op.metadata.sourceToken} for region ${regionalDeployment.region}`);
            regionalDeployment.sourceToken = op.metadata.sourceToken;
            finishRegionalFunctionDeployment(params, regionalDeployment, queue);
        }
    };
    if (regionalDeployment.functionsToCreate.length) {
        const firstFn = regionalDeployment.functionsToCreate.shift();
        const task = createFunctionTask(params, firstFn, onPollFn);
        return queue.run(task);
    }
    else if (regionalDeployment.functionsToUpdate.length) {
        const firstFn = regionalDeployment.functionsToUpdate.shift();
        const task = updateFunctionTask(params, firstFn, onPollFn);
        return queue.run(task);
    }
    return Promise.resolve();
}
exports.runRegionalFunctionDeployment = runRegionalFunctionDeployment;
function finishRegionalFunctionDeployment(params, regionalDeployment, queue) {
    params.sourceToken = regionalDeployment.sourceToken;
    for (const fn of regionalDeployment.functionsToCreate) {
        queue.run(createFunctionTask(params, fn));
    }
    for (const fn of regionalDeployment.functionsToUpdate) {
        queue.run(updateFunctionTask(params, fn));
    }
}
