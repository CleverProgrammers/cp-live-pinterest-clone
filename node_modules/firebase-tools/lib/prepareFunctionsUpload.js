"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareFunctionsUpload = void 0;
const _ = require("lodash");
const archiver = require("archiver");
const clc = require("cli-color");
const filesize = require("filesize");
const fs = require("fs");
const path = require("path");
const tmp = require("tmp");
const error_1 = require("./error");
const functionsConfig = require("./functionsConfig");
const getProjectId = require("./getProjectId");
const logger = require("./logger");
const utils = require("./utils");
const parseTriggers = require("./parseTriggers");
const fsAsync = require("./fsAsync");
const CONFIG_DEST_FILE = ".runtimeconfig.json";
async function getFunctionsConfig(context) {
    let config = {};
    if (context.runtimeConfigEnabled) {
        try {
            config = await functionsConfig.materializeAll(context.firebaseConfig.projectId);
        }
        catch (err) {
            logger.debug(err);
            const errorCode = _.get(err, "context.response.statusCode");
            if (errorCode === 500 || errorCode === 503) {
                throw new error_1.FirebaseError("Cloud Runtime Config is currently experiencing issues, " +
                    "which is preventing your functions from being deployed. " +
                    "Please wait a few minutes and then try to deploy your functions again." +
                    "\nRun `firebase deploy --except functions` if you want to continue deploying the rest of your project.");
            }
            config = {};
        }
    }
    const firebaseConfig = _.get(context, "firebaseConfig");
    _.set(config, "firebase", firebaseConfig);
    return config;
}
async function pipeAsync(from, to) {
    return new Promise((resolve, reject) => {
        to.on("finish", resolve);
        to.on("error", reject);
        from.pipe(to);
    });
}
async function packageSource(options, sourceDir, configValues) {
    const tmpFile = tmp.fileSync({ prefix: "firebase-functions-", postfix: ".zip" }).name;
    const fileStream = fs.createWriteStream(tmpFile, {
        flags: "w",
        encoding: "binary",
    });
    const archive = archiver("zip");
    const ignore = options.config.get("functions.ignore", ["node_modules", ".git"]);
    ignore.push("firebase-debug.log", "firebase-debug.*.log", CONFIG_DEST_FILE);
    try {
        const files = await fsAsync.readdirRecursive({ path: sourceDir, ignore: ignore });
        _.forEach(files, (file) => {
            archive.file(file.name, {
                name: path.relative(sourceDir, file.name),
                mode: file.mode,
            });
        });
        archive.append(JSON.stringify(configValues, null, 2), {
            name: CONFIG_DEST_FILE,
            mode: 420,
        });
        archive.finalize();
        await pipeAsync(archive, fileStream);
    }
    catch (err) {
        throw new error_1.FirebaseError("Could not read source directory. Remove links and shortcuts and try again.", {
            original: err,
            exit: 1,
        });
    }
    utils.logBullet(clc.cyan.bold("functions:") +
        " packaged " +
        clc.bold(options.config.get("functions.source")) +
        " (" +
        filesize(archive.pointer()) +
        ") for uploading");
    return {
        file: tmpFile,
        stream: fs.createReadStream(tmpFile),
        size: archive.pointer(),
    };
}
async function prepareFunctionsUpload(context, options) {
    const sourceDir = options.config.path(options.config.get("functions.source"));
    const configValues = await getFunctionsConfig(context);
    const triggers = await parseTriggers(getProjectId(options), sourceDir, configValues);
    options.config.set("functions.triggers", triggers);
    if (triggers.length === 0) {
        return;
    }
    return packageSource(options, sourceDir, configValues);
}
exports.prepareFunctionsUpload = prepareFunctionsUpload;
