"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanAuthState = exports.getCleanDomains = exports.removeAuthDomain = exports.addAuthDomains = exports.createRelease = exports.cloneVersion = exports.deleteChannel = exports.updateChannelTtl = exports.createChannel = exports.listChannels = exports.getChannel = exports.normalizeName = void 0;
const error_1 = require("../error");
const api_1 = require("../api");
const apiv2_1 = require("../apiv2");
const operationPoller = require("../operation-poller");
const expireUtils_1 = require("../hosting/expireUtils");
const auth_1 = require("../gcp/auth");
const ONE_WEEK_MS = 604800000;
var ReleaseType;
(function (ReleaseType) {
    ReleaseType["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
    ReleaseType["DEPLOY"] = "DEPLOY";
    ReleaseType["ROLLBACK"] = "ROLLBACK";
    ReleaseType["SITE_DISABLE"] = "SITE_DISABLE";
})(ReleaseType || (ReleaseType = {}));
var VersionStatus;
(function (VersionStatus) {
    VersionStatus["VERSION_STATUS_UNSPECIFIED"] = "VERSION_STATUS_UNSPECIFIED";
    VersionStatus["CREATED"] = "CREATED";
    VersionStatus["FINALIZED"] = "FINALIZED";
    VersionStatus["DELETED"] = "DELETED";
    VersionStatus["ABANDONED"] = "ABANDONED";
    VersionStatus["EXPIRED"] = "EXPIRED";
    VersionStatus["CLONING"] = "CLONING";
})(VersionStatus || (VersionStatus = {}));
var ServingConfig;
(function (ServingConfig) {
})(ServingConfig || (ServingConfig = {}));
function normalizeName(s) {
    return s.replace(/[/:_#]/g, "-");
}
exports.normalizeName = normalizeName;
const apiClient = new apiv2_1.Client({
    urlPrefix: api_1.hostingApiOrigin,
    apiVersion: "v1beta1",
    auth: true,
});
async function getChannel(project = "-", site, channelId) {
    try {
        const res = await apiClient.get(`/projects/${project}/sites/${site}/channels/${channelId}`);
        return res.body;
    }
    catch (e) {
        if (e.status === 404) {
            return null;
        }
        throw e;
    }
}
exports.getChannel = getChannel;
async function listChannels(project = "-", site) {
    var _a, _b;
    const channels = [];
    let nextPageToken = "";
    for (;;) {
        try {
            const res = await apiClient.get(`/projects/${project}/sites/${site}/channels`, { queryParams: { pageToken: nextPageToken, pageSize: 10 } });
            const c = (_a = res.body) === null || _a === void 0 ? void 0 : _a.channels;
            if (c) {
                channels.push(...c);
            }
            nextPageToken = ((_b = res.body) === null || _b === void 0 ? void 0 : _b.nextPageToken) || "";
            if (!nextPageToken) {
                return channels;
            }
        }
        catch (e) {
            if (e.status === 404) {
                throw new error_1.FirebaseError(`could not find channels for site "${site}"`, {
                    original: e,
                });
            }
            throw e;
        }
    }
}
exports.listChannels = listChannels;
async function createChannel(project = "-", site, channelId, ttlMillis = expireUtils_1.DEFAULT_DURATION) {
    const res = await apiClient.post(`/projects/${project}/sites/${site}/channels?channelId=${channelId}`, { ttl: `${ttlMillis / 1000}s` });
    return res.body;
}
exports.createChannel = createChannel;
async function updateChannelTtl(project = "-", site, channelId, ttlMillis = ONE_WEEK_MS) {
    const res = await apiClient.patch(`/projects/${project}/sites/${site}/channels/${channelId}`, { ttl: `${ttlMillis / 1000}s` }, { queryParams: { updateMask: ["ttl"].join(",") } });
    return res.body;
}
exports.updateChannelTtl = updateChannelTtl;
async function deleteChannel(project = "-", site, channelId) {
    await apiClient.delete(`/projects/${project}/sites/${site}/channels/${channelId}`);
}
exports.deleteChannel = deleteChannel;
async function cloneVersion(site, versionName, finalize = false) {
    const res = await apiClient.post(`/projects/-/sites/${site}/versions:clone`, {
        sourceVersion: versionName,
        finalize,
    });
    const { name: operationName } = res.body;
    const pollRes = await operationPoller.pollOperation({
        apiOrigin: api_1.hostingApiOrigin,
        apiVersion: "v1beta1",
        operationResourceName: operationName,
        masterTimeout: 600000,
    });
    return pollRes;
}
exports.cloneVersion = cloneVersion;
async function createRelease(site, channel, version) {
    const res = await apiClient.request({
        method: "POST",
        path: `/projects/-/sites/${site}/channels/${channel}/releases`,
        queryParams: { versionName: version },
    });
    return res.body;
}
exports.createRelease = createRelease;
async function addAuthDomains(project, urls) {
    const domains = await auth_1.getAuthDomains(project);
    const authDomains = domains || [];
    for (const url of urls) {
        const domain = url.replace("https://", "");
        if (authDomains.includes(domain)) {
            continue;
        }
        authDomains.push(domain);
    }
    return await auth_1.updateAuthDomains(project, authDomains);
}
exports.addAuthDomains = addAuthDomains;
async function removeAuthDomain(project, url) {
    const domains = await auth_1.getAuthDomains(project);
    if (!domains.length) {
        return domains;
    }
    const targetDomain = url.replace("https://", "");
    const authDomains = domains.filter((domain) => domain != targetDomain);
    return auth_1.updateAuthDomains(project, authDomains);
}
exports.removeAuthDomain = removeAuthDomain;
async function getCleanDomains(project, site) {
    const channels = await listChannels(project, site);
    const channelMap = channels
        .map((channel) => channel.url.replace("https://", ""))
        .reduce((acc, current) => {
        acc[current] = true;
        return acc;
    }, {});
    const siteMatch = new RegExp(`${site}--`, "i");
    const firebaseAppMatch = new RegExp(/firebaseapp.com$/);
    const domains = await auth_1.getAuthDomains(project);
    const authDomains = [];
    domains.forEach((domain) => {
        const endsWithFirebaseApp = firebaseAppMatch.test(domain);
        if (endsWithFirebaseApp) {
            authDomains.push(domain);
            return;
        }
        const domainWithNoChannel = siteMatch.test(domain) && !channelMap[domain];
        if (domainWithNoChannel) {
            return;
        }
        authDomains.push(domain);
    });
    return authDomains;
}
exports.getCleanDomains = getCleanDomains;
async function cleanAuthState(project, sites) {
    const siteDomainMap = new Map();
    for (const site of sites) {
        const authDomains = await getCleanDomains(project, site);
        const updatedDomains = await auth_1.updateAuthDomains(project, authDomains);
        siteDomainMap.set(site, updatedDomains);
    }
    return siteDomainMap;
}
exports.cleanAuthState = cleanAuthState;
