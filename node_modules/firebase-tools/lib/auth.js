"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logout = exports.getAccessToken = exports.loginGithub = exports.loginGoogle = void 0;
const clc = require("cli-color");
const fs = require("fs");
const jwt = require("jsonwebtoken");
const http = require("http");
const opn = require("open");
const path = require("path");
const portfinder = require("portfinder");
const url = require("url");
const util = require("util");
const api = require("./api");
const configstore_1 = require("./configstore");
const error_1 = require("./error");
const logger = require("./logger");
const prompt_1 = require("./prompt");
const scopes = require("./scopes");
portfinder.basePort = 9005;
function open(url) {
    opn(url).catch((err) => {
        logger.debug("Unable to open URL: " + err.stack);
    });
}
function invalidCredentialError() {
    return new error_1.FirebaseError("Authentication Error: Your credentials are no longer valid. Please run " +
        clc.bold("firebase login --reauth") +
        "\n\n" +
        "For CI servers and headless environments, generate a new token with " +
        clc.bold("firebase login:ci"), { exit: 1 });
}
const FIFTEEN_MINUTES_IN_MS = 15 * 60 * 1000;
const SCOPES = [
    scopes.EMAIL,
    scopes.OPENID,
    scopes.CLOUD_PROJECTS_READONLY,
    scopes.FIREBASE_PLATFORM,
    scopes.CLOUD_PLATFORM,
];
const _nonce = Math.floor(Math.random() * (2 << 29) + 1).toString();
const getPort = portfinder.getPortPromise;
let lastAccessToken;
function getCallbackUrl(port) {
    if (typeof port === "undefined") {
        return "urn:ietf:wg:oauth:2.0:oob";
    }
    return `http://localhost:${port}`;
}
function queryParamString(args) {
    const tokens = [];
    for (const [key, value] of Object.entries(args)) {
        if (typeof value === "string") {
            tokens.push(key + "=" + encodeURIComponent(value));
        }
    }
    return tokens.join("&");
}
function getLoginUrl(callbackUrl, userHint) {
    return (api.authOrigin +
        "/o/oauth2/auth?" +
        queryParamString({
            client_id: api.clientId,
            scope: SCOPES.join(" "),
            response_type: "code",
            state: _nonce,
            redirect_uri: callbackUrl,
            login_hint: userHint,
        }));
}
async function getTokensFromAuthorizationCode(code, callbackUrl) {
    var _a, _b;
    let res;
    try {
        res = await api.request("POST", "/o/oauth2/token", {
            origin: api.authOrigin,
            form: {
                code: code,
                client_id: api.clientId,
                client_secret: api.clientSecret,
                redirect_uri: callbackUrl,
                grant_type: "authorization_code",
            },
        });
    }
    catch (err) {
        if (err instanceof Error) {
            logger.debug("Token Fetch Error:", err.stack || "");
        }
        else {
            logger.debug("Token Fetch Error");
        }
        throw invalidCredentialError();
    }
    if (!((_a = res === null || res === void 0 ? void 0 : res.body) === null || _a === void 0 ? void 0 : _a.access_token) && !((_b = res === null || res === void 0 ? void 0 : res.body) === null || _b === void 0 ? void 0 : _b.refresh_token)) {
        logger.debug("Token Fetch Error:", res.statusCode, res.body);
        throw invalidCredentialError();
    }
    lastAccessToken = Object.assign({
        expires_at: Date.now() + res.body.expires_in * 1000,
    }, res.body);
    return lastAccessToken;
}
const GITHUB_SCOPES = ["read:user", "repo", "public_repo"];
function getGithubLoginUrl(callbackUrl) {
    return (api.githubOrigin +
        "/login/oauth/authorize?" +
        queryParamString({
            client_id: api.githubClientId,
            state: _nonce,
            redirect_uri: callbackUrl,
            scope: GITHUB_SCOPES.join(" "),
        }));
}
async function getGithubTokensFromAuthorizationCode(code, callbackUrl) {
    const res = await api.request("POST", "/login/oauth/access_token", {
        origin: api.githubOrigin,
        form: {
            client_id: api.githubClientId,
            client_secret: api.githubClientSecret,
            code,
            redirect_uri: callbackUrl,
            state: _nonce,
        },
    });
    return res.body.access_token;
}
async function respondWithFile(req, res, statusCode, filename) {
    const response = await util.promisify(fs.readFile)(path.join(__dirname, filename));
    res.writeHead(statusCode, {
        "Content-Length": response.length,
        "Content-Type": "text/html",
    });
    res.end(response);
    req.socket.destroy();
}
async function loginWithoutLocalhost(userHint) {
    const callbackUrl = getCallbackUrl();
    const authUrl = getLoginUrl(callbackUrl, userHint);
    logger.info();
    logger.info("Visit this URL on any device to log in:");
    logger.info(clc.bold.underline(authUrl));
    logger.info();
    open(authUrl);
    const answers = await prompt_1.prompt({}, [
        {
            type: "input",
            name: "code",
            message: "Paste authorization code here:",
        },
    ]);
    const tokens = await getTokensFromAuthorizationCode(answers.code, callbackUrl);
    return {
        user: jwt.decode(tokens.id_token),
        tokens: tokens,
        scopes: SCOPES,
    };
}
async function loginWithLocalhostGoogle(port, userHint) {
    const callbackUrl = getCallbackUrl(port);
    const authUrl = getLoginUrl(callbackUrl, userHint);
    const successTemplate = "../templates/loginSuccess.html";
    const tokens = await loginWithLocalhost(port, callbackUrl, authUrl, successTemplate, getTokensFromAuthorizationCode);
    return {
        user: jwt.decode(tokens.id_token),
        tokens: tokens,
        scopes: tokens.scopes,
    };
}
async function loginWithLocalhostGitHub(port) {
    const callbackUrl = getCallbackUrl(port);
    const authUrl = getGithubLoginUrl(callbackUrl);
    const successTemplate = "../templates/loginSuccessGithub.html";
    return loginWithLocalhost(port, callbackUrl, authUrl, successTemplate, getGithubTokensFromAuthorizationCode);
}
async function loginWithLocalhost(port, callbackUrl, authUrl, successTemplate, getTokens) {
    return new Promise((resolve, reject) => {
        const server = http.createServer(async (req, res) => {
            let tokens;
            const query = url.parse(`${req.url}`, true).query || {};
            const queryState = query.state;
            const queryCode = query.code;
            if (queryState !== _nonce || typeof queryCode !== "string") {
                await respondWithFile(req, res, 400, "../templates/loginFailure.html");
                reject(new error_1.FirebaseError("Unexpected error while logging in"));
                server.close();
                return;
            }
            try {
                const tokens = await getTokens(queryCode, callbackUrl);
                await respondWithFile(req, res, 200, successTemplate);
                resolve(tokens);
            }
            catch (err) {
                await respondWithFile(req, res, 400, "../templates/loginFailure.html");
                reject(err);
            }
            server.close();
            return;
        });
        server.listen(port, () => {
            logger.info();
            logger.info("Visit this URL on this device to log in:");
            logger.info(clc.bold.underline(authUrl));
            logger.info();
            logger.info("Waiting for authentication...");
            open(authUrl);
        });
        server.on("error", (err) => {
            reject(err);
        });
    });
}
async function loginGoogle(localhost, userHint) {
    if (localhost) {
        const port = await getPort();
        try {
            const port = await getPort();
            return await loginWithLocalhostGoogle(port, userHint);
        }
        catch (_a) {
            return await loginWithoutLocalhost(userHint);
        }
    }
    return await loginWithoutLocalhost(userHint);
}
exports.loginGoogle = loginGoogle;
async function loginGithub() {
    const port = await getPort();
    return loginWithLocalhostGitHub(port);
}
exports.loginGithub = loginGithub;
function haveValidTokens(refreshToken, authScopes) {
    var _a;
    if (!(lastAccessToken === null || lastAccessToken === void 0 ? void 0 : lastAccessToken.access_token)) {
        const tokens = configstore_1.configstore.get("tokens");
        if (refreshToken === (tokens === null || tokens === void 0 ? void 0 : tokens.refresh_token)) {
            lastAccessToken = tokens;
        }
    }
    const hasTokens = !!(lastAccessToken === null || lastAccessToken === void 0 ? void 0 : lastAccessToken.access_token);
    const oldScopesJSON = JSON.stringify(((_a = lastAccessToken === null || lastAccessToken === void 0 ? void 0 : lastAccessToken.scopes) === null || _a === void 0 ? void 0 : _a.sort()) || []);
    const newScopesJSON = JSON.stringify(authScopes.sort());
    const hasSameScopes = oldScopesJSON === newScopesJSON;
    const isExpired = ((lastAccessToken === null || lastAccessToken === void 0 ? void 0 : lastAccessToken.expires_at) || 0) < Date.now() + FIFTEEN_MINUTES_IN_MS;
    return hasTokens && hasSameScopes && !isExpired;
}
function logoutCurrentSession(refreshToken) {
    const tokens = configstore_1.configstore.get("tokens");
    const currentToken = tokens === null || tokens === void 0 ? void 0 : tokens.refresh_token;
    if (refreshToken === currentToken) {
        configstore_1.configstore.delete("user");
        configstore_1.configstore.delete("tokens");
        configstore_1.configstore.delete("usage");
        configstore_1.configstore.delete("analytics-uuid");
    }
}
async function refreshTokens(refreshToken, authScopes) {
    var _a, _b, _c, _d;
    logger.debug("> refreshing access token with scopes:", JSON.stringify(authScopes));
    try {
        const res = await api.request("POST", "/oauth2/v3/token", {
            origin: api.googleOrigin,
            form: {
                refresh_token: refreshToken,
                client_id: api.clientId,
                client_secret: api.clientSecret,
                grant_type: "refresh_token",
                scope: (authScopes || []).join(" "),
            },
            logOptions: { skipRequestBody: true, skipQueryParams: true, skipResponseBody: true },
        });
        if (res.status === 401 || res.status === 400) {
            return { access_token: refreshToken };
        }
        if (typeof ((_a = res.body) === null || _a === void 0 ? void 0 : _a.access_token) !== "string") {
            throw invalidCredentialError();
        }
        lastAccessToken = Object.assign({
            expires_at: Date.now() + res.body.expires_in * 1000,
            refresh_token: refreshToken,
            scopes: authScopes,
        }, res.body);
        const currentRefreshToken = (_b = configstore_1.configstore.get("tokens")) === null || _b === void 0 ? void 0 : _b.refresh_token;
        if (refreshToken === currentRefreshToken) {
            configstore_1.configstore.set("tokens", lastAccessToken);
        }
        return lastAccessToken;
    }
    catch (err) {
        if (((_d = (_c = err === null || err === void 0 ? void 0 : err.context) === null || _c === void 0 ? void 0 : _c.body) === null || _d === void 0 ? void 0 : _d.error) === "invalid_scope") {
            throw new error_1.FirebaseError("This command requires new authorization scopes not granted to your current session. Please run " +
                clc.bold("firebase login --reauth") +
                "\n\n" +
                "For CI servers and headless environments, generate a new token with " +
                clc.bold("firebase login:ci"), { exit: 1 });
        }
        throw invalidCredentialError();
    }
}
async function getAccessToken(refreshToken, authScopes) {
    if (haveValidTokens(refreshToken, authScopes)) {
        return lastAccessToken;
    }
    return refreshTokens(refreshToken, authScopes);
}
exports.getAccessToken = getAccessToken;
async function logout(refreshToken) {
    if ((lastAccessToken === null || lastAccessToken === void 0 ? void 0 : lastAccessToken.refresh_token) === refreshToken) {
        lastAccessToken = undefined;
    }
    logoutCurrentSession(refreshToken);
    try {
        await api.request("GET", "/o/oauth2/revoke", {
            origin: api.authOrigin,
            data: {
                token: refreshToken,
            },
        });
    }
    catch (thrown) {
        const err = thrown instanceof Error ? thrown : new Error(thrown);
        throw new error_1.FirebaseError("Authentication Error.", {
            exit: 1,
            original: err,
        });
    }
}
exports.logout = logout;
